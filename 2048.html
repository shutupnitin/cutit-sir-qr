<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-70PVFGLP9G"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-70PVFGLP9G');
</script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>2048 ✦ CutIt.sbs</title>
  <link href="https://fonts.googleapis.com/css2?family=Antonio:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%;
      font-family: 'Antonio', sans-serif;
      background: #000; color: #fff;
      overflow: hidden;
    }

    /* SCOREBOARD */
    #scoreboard {
      display: flex; justify-content: space-between;
      width: 90vmin; max-width: 500px;
      margin: 20px auto;
    }
    .score-box {
      background: #111; border-radius: 6px;
      padding: 10px 20px; text-align: center;
    }
    .score-box .label {
      font-size: 0.8rem; color: #bbb;
      text-transform: uppercase;
    }
    .score-box .number {
      font-size: 1.6rem; margin-top: 5px;
    }

    /* GRID */
    #grid-container {
      position: relative;
      width: 90vmin; max-width: 500px;
      height: 90vmin; max-height: 500px;
      margin: 0 auto;
      background: #222;
      border-radius: 8px;
      touch-action: none;
    }
    .grid-cell {
      position: absolute;
      background: #111;
      border-radius: 4px;
    }
    .tile {
      position: absolute;
      display: flex; align-items: center; justify-content: center;
      font-weight: bold;
      border-radius: 4px;
      transition: transform 0.2s ease, background 0.2s ease;
    }
    .tile.new {
      animation: pop 0.2s ease-out;
    }
    @keyframes pop {
      from { transform: scale(0); }
      to   { transform: scale(1); }
    }

    /* MODALS */
    .modal {
      position: fixed; top:0; left:0;
      width:100%; height:100%;
      display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,0.85);
      visibility:hidden; opacity:0;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      z-index:10;
    }
    .modal.active {
      visibility: visible; opacity:1;
    }
    .modal-content {
      background:#111; padding:2rem;
      border-radius:8px; text-align:center;
      max-width:90%;
    }
    .modal-content h2 {
      margin-bottom:1rem; font-size:1.4rem;
    }
    .modal-content p {
      margin-bottom:1.5rem; line-height:1.4;
    }
    .btn {
      background: #fff; color: #000;
      padding: 0.6rem 1.2rem; border:none;
      border-radius:4px; cursor:pointer;
      font-family:'Antonio',sans-serif;
      margin: 0 5px;
    }

    /* WATERMARK */
    #watermark {
      position: fixed; bottom:10px; width:100%;
      text-align:center; color:#fff; opacity:0.1;
      font-size:0.8rem; pointer-events:none;
      user-select:none;
    }
  </style>
</head>
<body>

  <!-- SCOREBOARD -->
  <div id="scoreboard">
    <div class="score-box">
      <div class="label">Score</div>
      <div id="score" class="number">0</div>
    </div>
    <div class="score-box">
      <div class="label">Best</div>
      <div id="best" class="number">0</div>
    </div>
  </div>

  <!-- GRID -->
  <div id="grid-container"></div>

  <!-- MODALS -->
  <div id="modal-start" class="modal active">
    <div class="modal-content">
      <h2>How to Play</h2>
      <p>Swipe on mobile or use arrow keys to move tiles. Equal tiles merge. Reach 2048 to win!</p>
      <button id="start-btn" class="btn">Start Game</button>
    </div>
  </div>
  <div id="modal-win" class="modal">
    <div class="modal-content">
      <h2>You Win!</h2>
      <p>CutIt.sbs ✦ your vibe. your code</p>
      <button id="win-play" class="btn">Play Again</button>
      <button id="win-home" class="btn">Home</button>
    </div>
  </div>
  <div id="modal-lose" class="modal">
    <div class="modal-content">
      <h2>Game Over</h2>
      <button id="lose-play" class="btn">Play Again</button>
      <button id="lose-home" class="btn">Home</button>
    </div>
  </div>

  <!-- WATERMARK -->
  <div id="watermark">CutIt.sbs ✦ your vibe. your code</div>

  <script>
  (function(){
    const SIZE = 4, WIN_VALUE = 2048, GAP = 10;
    let grid, score, best = parseInt(localStorage.getItem('bestScore')) || 0;

    const gc        = document.getElementById('grid-container'),
          scoreEl   = document.getElementById('score'),
          bestEl    = document.getElementById('best'),
          startModal= document.getElementById('modal-start'),
          winModal  = document.getElementById('modal-win'),
          loseModal = document.getElementById('modal-lose');

    // initial render of best
    bestEl.textContent = best;

    // resize & show start
    resizeGrid();
    window.addEventListener('resize', resizeGrid);
    showModal(startModal);

    // modal button handlers
    document.getElementById('start-btn').onclick = ()=>{ hideAllModals(); startGame(); };
    document.getElementById('win-play').onclick = ()=>{ hideAllModals(); startGame(); };
    document.getElementById('win-home').onclick = ()=>{ hideAllModals(); showModal(startModal); };
    document.getElementById('lose-play').onclick = ()=>{ hideAllModals(); startGame(); };
    document.getElementById('lose-home').onclick = ()=>{ hideAllModals(); showModal(startModal); };

    // keyboard
    window.addEventListener('keydown', e=>{
      if (e.key.startsWith('Arrow')) {
        e.preventDefault();
        handleMove(e.key);
      }
    });

    // touch
    let tX, tY;
    gc.addEventListener('touchstart', e=>{
      tX = e.touches[0].clientX; tY = e.touches[0].clientY;
    });
    gc.addEventListener('touchend', e=>{
      const dx = e.changedTouches[0].clientX - tX;
      const dy = e.changedTouches[0].clientY - tY;
      if (Math.hypot(dx,dy)<30) return;
      if (Math.abs(dx)>Math.abs(dy)) {
        handleMove(dx>0?'ArrowRight':'ArrowLeft');
      } else {
        handleMove(dy>0?'ArrowDown':'ArrowUp');
      }
    });

    // START a new game
    function startGame(){
      score = 0; updateScore();
      grid = Array.from({length:SIZE}, ()=>Array(SIZE).fill(0));
      addTile(); addTile();
      updateUI();
    }

    // show / hide
    function showModal(m){ [startModal, winModal, loseModal].forEach(x=>x.classList.remove('active')); m.classList.add('active'); }
    function hideAllModals(){ [startModal, winModal, loseModal].forEach(x=>x.classList.remove('active')); }

    // grid resize
    function resizeGrid(){
      const s = Math.min(window.innerWidth, window.innerHeight)*0.9;
      gc.style.width = gc.style.height = s + 'px';
    }

    // add 2 or 4 to a random empty cell
    function addTile(){
      const empties = [];
      grid.forEach((row,r)=>row.forEach((v,c)=>{ if(!v) empties.push({r,c}); }));
      if (!empties.length) return;
      const {r,c} = empties[Math.floor(Math.random()*empties.length)];
      grid[r][c] = Math.random()<0.9?2:4;
    }

    // slide+merge helper
    function slideAndCombine(row){
      const arr = row.filter(v=>v);
      for (let i=0;i<arr.length-1;i++){
        if (arr[i] === arr[i+1]) {
          arr[i] *= 2;
          score += arr[i];
          arr[i+1] = 0;
          i++;
        }
      }
      const merged = arr.filter(v=>v);
      return merged.concat(Array(row.length-merged.length).fill(0));
    }

    // perform one of four moves
    function move(dir){
      let moved = false;
      if (dir==='ArrowLeft'){
        for (let r=0;r<SIZE;r++){
          const old = grid[r].slice();
          const nw  = slideAndCombine(old);
          grid[r] = nw;
          if (!moved && nw.some((v,i)=>v!==old[i])) moved = true;
        }
      }
      if (dir==='ArrowRight'){
        for (let r=0;r<SIZE;r++){
          const old = grid[r].slice();
          const rev = old.slice().reverse();
          const nw  = slideAndCombine(rev).reverse();
          grid[r] = nw;
          if (!moved && nw.some((v,i)=>v!==old[i])) moved = true;
        }
      }
      if (dir==='ArrowUp'){
        for (let c=0;c<SIZE;c++){
          const col = grid.map(r=>r[c]);
          const nw  = slideAndCombine(col);
          for (let r=0;r<SIZE;r++){
            if (grid[r][c] !== nw[r]) moved = true;
            grid[r][c] = nw[r];
          }
        }
      }
      if (dir==='ArrowDown'){
        for (let c=0;c<SIZE;c++){
          const col = grid.map(r=>r[c]).reverse();
          const nw  = slideAndCombine(col).reverse();
          for (let r=0;r<SIZE;r++){
            if (grid[r][c] !== nw[r]) moved = true;
            grid[r][c] = nw[r];
          }
        }
      }
      return moved;
    }

    // trigger a move & check end
    function handleMove(key){
      if ( startModal.classList.contains('active')
        || winModal.classList.contains('active')
        || loseModal.classList.contains('active')) return;

      const didMove = move(key);
      if (!didMove) return;

      addTile();
      updateUI();

      if (checkWin())   showModal(winModal);
      else if (!canMove()) showModal(loseModal);
    }

    // win if any tile ≥ 2048
    function checkWin(){
      return grid.flat().some(v=>v>=WIN_VALUE);
    }

    // any empty or mergeable neighbour?
    function canMove(){
      for (let r=0;r<SIZE;r++){
        for (let c=0;c<SIZE;c++){
          if (!grid[r][c]) return true;
          if (c<SIZE-1 && grid[r][c]===grid[r][c+1]) return true;
          if (r<SIZE-1 && grid[r][c]===grid[r+1][c]) return true;
        }
      }
      return false;
    }

    // update score & best
    function updateScore(){
      scoreEl.textContent = score;
      if (score>best){
        best = score;
        localStorage.setItem('bestScore', best);
        bestEl.textContent = best;
      }
    }

    // draw grid + tiles
    function updateUI(){
      gc.innerHTML = '';
      const W = gc.clientWidth;
      const cellSize = (W - GAP*(SIZE+1))/SIZE;

      // background cells
      for (let r=0;r<SIZE;r++){
        for (let c=0;c<SIZE;c++){
          const cell = document.createElement('div');
          cell.className = 'grid-cell';
          cell.style.width  = cell.style.height = cellSize + 'px';
          cell.style.left   = (GAP + c*(cellSize+GAP)) + 'px';
          cell.style.top    = (GAP + r*(cellSize+GAP)) + 'px';
          gc.appendChild(cell);
        }
      }

      // number tiles
      grid.forEach((row,r)=>{
        row.forEach((v,c)=>{
          if (!v) return;
          const tile = document.createElement('div');
          tile.className = 'tile new';
          tile.textContent = v;

          // dynamic greyscale
          const bg = 255 - Math.min(240, Math.log2(v)*15);
          tile.style.background = `rgb(${bg},${bg},${bg})`;
          tile.style.color      = bg<100?'#fff':'#000';

          tile.style.width  = tile.style.height = cellSize + 'px';
          tile.style.left   = (GAP + c*(cellSize+GAP)) + 'px';
          tile.style.top    = (GAP + r*(cellSize+GAP)) + 'px';
          gc.appendChild(tile);

          tile.addEventListener('animationend', ()=> tile.classList.remove('new'));
        });
      });

      updateScore();
    }
  })();
  </script>
</body>
</html>

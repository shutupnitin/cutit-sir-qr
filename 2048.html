<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>2048 ✦ CutIt.sbs</title>
  <link href="https://fonts.googleapis.com/css2?family=Antonio:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; background: #000; color: #fff; font-family: 'Antonio', sans-serif; }
    #game-container { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; }
    #scoreboard { display: flex; gap: 1rem; margin-bottom: 1rem; }
    .score-box { background: #111; padding: 0.5rem 1rem; border-radius: 4px; text-align: center; }
    .score-box div { font-size: 0.9rem; }
    .score-box span { font-size: 1.4rem; display: block; }
    #grid-container { position: relative; background: #222; border-radius: 6px; touch-action: none; }
    .grid-cell {
      position: absolute; background: #111; border-radius: 4px;
    }
    .tile {
      position: absolute; display: flex; align-items: center; justify-content: center;
      font-size: 1.2rem; font-weight: bold; border-radius: 4px;
      transition: transform 0.15s ease, background 0.2s;
    }
    .tile.new { animation: pop 0.15s ease-out; }
    @keyframes pop { from { transform: scale(0); } to { transform: scale(1); } }
    .modal {
      position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.85);
      display: flex; align-items: center; justify-content: center; z-index: 10; visibility: hidden;
    }
    .modal.active { visibility: visible; }
    .modal-content {
      background: #111; padding: 2rem; border-radius: 6px; text-align: center; max-width: 90vw;
    }
    .modal-content h2 { margin-bottom: 1rem; }
    .modal-content p { margin-bottom: 1.5rem; line-height: 1.4; }
    .btn {
      background: #fff; color: #000; padding: 0.6rem 1.2rem; border: none;
      border-radius: 4px; cursor: pointer; font-family: 'Antonio', sans-serif;
    }
    #watermark {
      position: fixed; bottom: 10px; width: 100%; text-align: center;
      color: #fff; opacity: 0.2; font-size: 0.8rem;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="scoreboard">
      <div class="score-box">
        <div>Score</div><span id="score">0</span>
      </div>
      <div class="score-box">
        <div>Best</div><span id="best">0</span>
      </div>
    </div>
    <div id="grid-container"></div>
  </div>

  <!-- Modals -->
  <div id="modal-start" class="modal active">
    <div class="modal-content">
      <h2>How to Play</h2>
      <p>Swipe or use arrow keys to move tiles. Matching numbers merge. Reach 2048 to win!</p>
      <button class="btn" id="start-btn">Start Game</button>
    </div>
  </div>
  <div id="modal-win" class="modal">
    <div class="modal-content">
      <h2>You Win!</h2>
      <p>CutIt.sbs ✦ your vibe. your code</p>
      <button class="btn" id="win-play">Play Again</button>
      <button class="btn" id="win-home">Home</button>
    </div>
  </div>
  <div id="modal-lose" class="modal">
    <div class="modal-content">
      <h2>Game Over</h2>
      <button class="btn" id="lose-play">Play Again</button>
      <button class="btn" id="lose-home">Home</button>
    </div>
  </div>

  <div id="watermark">CutIt.sbs ✦ your vibe. your code</div>

  <script>
  (function(){
    const SIZE = 4, WIN_VALUE = 2048, GAP = 10;
    let grid = [], score = 0, best = +localStorage.getItem('bestScore') || 0;
    const gc = document.getElementById('grid-container'),
          scoreEl = document.getElementById('score'),
          bestEl  = document.getElementById('best');
    // initialize grid & background cells
    function initGrid() {
      gc.innerHTML = '';
      grid = Array(SIZE).fill().map(()=>Array(SIZE).fill(0));
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
        const cell = document.createElement('div');
        cell.classList.add('grid-cell');
        cell.style.width = cell.style.height = '0px'; // set later
        gc.appendChild(cell);
      }
      spawn(); spawn();
      updateUI();
    }
    // spawn a tile
    function spawn() {
      const empties = [];
      grid.forEach((row,r)=>row.forEach((v,c)=>!v && empties.push([r,c])));
      if(!empties.length) return;
      const [r,c] = empties[Math.floor(Math.random()*empties.length)];
      grid[r][c] = Math.random()<0.9?2:4;
    }
    // move & merge helpers
    function slide(row){
      let arr = row.filter(v=>v), changed = false;
      for(let i=0;i<arr.length-1;i++){
        if(arr[i]===arr[i+1]){ arr[i]*=2; score+=arr[i]; arr.splice(i+1,1); changed=true; }
      }
      while(arr.length< SIZE) arr.push(0);
      return {newRow: arr, changed: changed || arr.some((v,i)=>v!==row[i])};
    }
    function move(dir) {
      let moved=false;
      for(let i=0;i<SIZE;i++){
        let line = dir<2? grid[i].slice() : grid.map(r=>r[i]);
        if(dir>1) line.reverse();
        const {newRow, changed} = slide(line);
        if(changed){
          moved=true;
          const final = dir>1 ? newRow.reverse() : newRow;
          if(dir<2) grid[i]=final; else grid.forEach((r,j)=>r[i]=final[j]);
        }
      }
      if(moved){ spawn(); updateUI(); checkEnd(); }
    }
    function canMove() {
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
        if(!grid[r][c]) return true;
        [[1,0],[0,1]].forEach(([dr,dc])=>{
          const nr=r+dr, nc=c+dc;
          if(nr<SIZE && nc<SIZE && grid[nr][nc]===grid[r][c]) throw 'hasMove';
        });
      }
      return false;
    }
    function checkEnd(){
      if(grid.flat().includes(WIN_VALUE)){
        showModal('win');
      } else {
        try{ canMove(); } catch(e){ return; }
        showModal('lose');
      }
    }
    // render UI
    function updateUI(){
      scoreEl.textContent = score;
      if(score>best){ best=score; localStorage.setItem('bestScore',best); }
      bestEl.textContent = best;
      const W = gc.clientWidth;
      const cellSize = (W - GAP*(SIZE+1))/SIZE;
      // style grid cells
      Array.from(gc.children).forEach((cell,i)=>{
        const r = Math.floor(i/SIZE), c = i%SIZE;
        const x = GAP + c*(cellSize+GAP), y = GAP + r*(cellSize+GAP);
        Object.assign(cell.style,{width:cell.style.height=cellSize+'px', transform:`translate(${x}px,${y}px)`});
      });
      // remove old tiles
      document.querySelectorAll('.tile').forEach(t=>t.remove());
      // draw new tiles
      grid.forEach((row,r)=>row.forEach((v,c)=>{
        if(!v) return;
        const tile = document.createElement('div');
        tile.classList.add('tile','new');
        tile.textContent = v;
        const bg = 255 - Math.min(240, Math.log2(v)*15);
        tile.style.background = `rgb(${bg},${bg},${bg})`;
        tile.style.color = bg<100?'#fff':'#000';
        const x = GAP + c*(cellSize+GAP), y = GAP + r*(cellSize+GAP);
        Object.assign(tile.style,{width:cellSize+'px', height:cellSize+'px', transform:`translate(${x}px,${y}px)`});
        gc.appendChild(tile);
        // remove 'new' marker after animation
        tile.addEventListener('animationend',()=>tile.classList.remove('new'));
      }));
    }

    // swipe detection
    let sx, sy;
    gc.addEventListener('touchstart', e=>{ sx=e.touches[0].clientX; sy=e.touches[0].clientY; });
    gc.addEventListener('touchend', e=>{
      const dx=e.changedTouches[0].clientX-sx, dy=e.changedTouches[0].clientY-sy;
      if(Math.hypot(dx,dy)<30) return;
      if(Math.abs(dx)>Math.abs(dy)) move(dx>0?2:0); else move(dy>0?3:1);
    });
    // keyboard
    window.addEventListener('keydown', e=>{
      if(['ArrowLeft','ArrowUp','ArrowRight','ArrowDown'].includes(e.key)){
        e.preventDefault();
        move({ArrowLeft:0,ArrowUp:1,ArrowRight:2,ArrowDown:3}[e.key]);
      }
    });
    window.addEventListener('resize', updateUI);

    // modals
    const modals = { start: document.getElementById('modal-start'),
                     win: document.getElementById('modal-win'),
                     lose: document.getElementById('modal-lose') };
    function showModal(name){
      Object.values(modals).forEach(m=>m.classList.remove('active'));
      modals[name].classList.add('active');
    }
    function hideModals(){ Object.values(modals).forEach(m=>m.classList.remove('active')); }

    document.getElementById('start-btn').onclick = ()=>{
      hideModals(); score=0; initGrid();
    };
    document.getElementById('win-play').onclick = ()=>{ hideModals(); score=0; initGrid(); };
    document.getElementById('win-home').onclick = ()=> showModal('start');
    document.getElementById('lose-play').onclick = ()=>{ hideModals(); score=0; initGrid(); };
    document.getElementById('lose-home').onclick = ()=> showModal('start');

    // kick off
    bestEl.textContent = best;
  })();
  </script>
</body>
</html>
